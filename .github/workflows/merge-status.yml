# Updates the "Open PRs for Prod" GitHub issue with two tables:
# 1. All PRs merged to main
# 2. Main PR numbers that appear in prod branch commits (i.e. merged to prod)
name: Prod PR Tracking

on:
  schedule:
    # Run daily at 8 AM UTC
    - cron: '0 8 * * *'
  push:
    branches:
      - main
      - prod
  workflow_dispatch:
    inputs:
      prod_branch:
        description: 'Prod branch to scan for main PR references'
        required: false
        default: 'prod'

env:
  PROD_BRANCH: 'prod'
  ISSUE_TITLE: 'Open PRs for Prod'
  MAIN_PR_LIMIT: 150

jobs:
  update-prod-pr-issue:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      pull-requests: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set prod branch
        id: set_branch
        run: |
          if [[ -n "${{ github.event.inputs.prod_branch }}" ]]; then
            echo "branch=${{ github.event.inputs.prod_branch }}" >> $GITHUB_OUTPUT
          else
            echo "branch=${{ env.PROD_BRANCH }}" >> $GITHUB_OUTPUT
          fi

      - name: Fetch merged PRs to main and prod PR refs, then update issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prodBranch = '${{ steps.set_branch.outputs.branch }}';
            const issueTitle = process.env.ISSUE_TITLE || 'Open PRs for Prod';
            const mainPrLimit = parseInt(process.env.MAIN_PR_LIMIT || '150', 10);
            const { owner, repo } = context.repo;

            // 1) Fetch all merged PRs to main (paginated)
            const mergedToMain = [];
            let page = 1;
            const perPage = 100;
            while (true) {
              const { data } = await github.rest.pulls.list({
                owner,
                repo,
                state: 'closed',
                base: 'main',
                sort: 'updated',
                direction: 'desc',
                per_page: perPage,
                page
              });
              const merged = data.filter(pr => pr.merged_at != null);
              mergedToMain.push(...merged);
              if (data.length < perPage || mergedToMain.length >= mainPrLimit) break;
              page++;
            }
            const mainPrs = mergedToMain
              .sort((a, b) => new Date(b.merged_at) - new Date(a.merged_at))
              .slice(0, mainPrLimit);

            // 2) Fetch commits on prod branch and extract main PR numbers from messages
            const mainPrNumsInProd = new Set();
            let commitPage = 1;
            const commitPerPage = 100;
            let hasMoreCommits = true;
            while (hasMoreCommits) {
              const { data: commits } = await github.rest.repos.listCommits({
                owner,
                repo,
                sha: prodBranch,
                per_page: commitPerPage,
                page: commitPage
              });
              if (!commits || commits.length === 0) break;
              for (const commit of commits) {
                const msg = (commit.commit && commit.commit.message) || '';
                // Match (#1234) or #1234 in commit message (main PR references)
                const matches = msg.matchAll(/#(\d+)/g);
                for (const m of matches) mainPrNumsInProd.add(parseInt(m[1], 10));
              }
              if (commits.length < commitPerPage) break;
              commitPage++;
            }

            // 3) Build Table 1: All PRs merged to main
            let table1 = '| PR | Title | Merged at |\n|----|-------|----------|\n';
            for (const pr of mainPrs) {
              const mergedAt = pr.merged_at ? new Date(pr.merged_at).toISOString().split('T')[0] : '-';
              const title = (pr.title || '').replace(/\|/g, '\\|').replace(/\n/g, ' ');
              table1 += `| [#${pr.number}](${pr.html_url}) | ${title} | ${mergedAt} |\n`;
            }

            // 4) Build Table 2: Main PR numbers that are merged to prod (subset), sorted by PR number desc
            const inProdList = mainPrs
              .filter(pr => mainPrNumsInProd.has(pr.number))
              .sort((a, b) => b.number - a.number);
            let table2 = '| Main PR | Title | Merged to main |\n|---------|-------|----------------|\n';
            for (const pr of inProdList) {
              const mergedAt = pr.merged_at ? new Date(pr.merged_at).toISOString().split('T')[0] : '-';
              const title = (pr.title || '').replace(/\|/g, '\\|').replace(/\n/g, ' ');
              table2 += `| [#${pr.number}](${pr.html_url}) | ${title} | ${mergedAt} |\n`;
            }

            const openCount = mainPrs.length - inProdList.length;
            const body = [
              '## PRs merged to main',
              '',
              'Table of recent PRs merged to `main`.',
              '',
              table1,
              '---',
              '## Main PRs merged to prod',
              '',
              `Main PRs that appear in \`${prodBranch}\` commit messages (cherry-picks / references).`,
              '',
              table2,
              '---',
              `**Summary:** ${mainPrs.length} PRs merged to main (above). **${inProdList.length}** of those are in prod; **${openCount}** main PRs not yet in prod.`,
              '',
              `_Last updated by [Prod PR Tracking](${context.serverUrl}/${owner}/${repo}/actions/runs/${context.runId}) workflow._`
            ].join('\n');

            // 5) Find or create the issue
            const { data: search } = await github.rest.search.issuesAndPullRequests({
              q: `repo:${owner}/${repo} "${issueTitle}" is:issue`
            });
            const existing = search.items.length ? search.items[0] : null;
            let issueNumber = existing ? existing.number : null;

            if (issueNumber) {
              await github.rest.issues.update({
                owner,
                repo,
                issue_number: issueNumber,
                body
              });
              if (existing && existing.state === 'closed') {
                await github.rest.issues.update({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  state: 'open'
                });
              }
              console.log('Updated issue #' + issueNumber);
            } else {
              const { data: created } = await github.rest.issues.create({
                owner,
                repo,
                title: issueTitle,
                body
              });
              issueNumber = created.number;
              console.log('Created issue #' + issueNumber);
            }
            return { issue_number: issueNumber };
        env:
          ISSUE_TITLE: 'Open PRs for Prod'
          MAIN_PR_LIMIT: '150'
